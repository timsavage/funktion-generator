#include <string.h>
#include <pgmspace.h>
#include <FS.h>
#include "wave_tables.h"


// Offsets within wave file header.
#define VERSION_OFFSET  4
#define CHECKSUM_OFFSET 5
#define LENGTH_OFFSET   6
#define HEADER_LEN      8


// Definitions of error messages (that can be returns as pointers)
const char* const errorMessages[] {
  "OK",
  "File not found",
  "Invalid header",
  "Unknown file version",
  "Data checksum failed",
  "Error writing wave",
  "Unknown error code!"
};

extern const char* wt_errorMessage(uint8_t errorCode) {
  if (errorCode > WAVE_FILE_MAX_ERROR) {
    return errorMessages[WAVE_FILE_MAX_ERROR + 1];
  }
  return errorMessages[errorCode];
}

/**
 * Calculate checksum of a wave
 */
uint8_t calculateChecksum(WaveTable* wave) {
  uint8_t checksum = 0;
  for (size_t i = 0; i < WAVE_TABLE_LEN; i++) {
    checksum = checksum ^ wave->data[i];
  }
  return checksum;
}

/**
 * Load a wave table from ESP8266 filesystem.
 * 
 * @param wave - Pointer to a wavetable to load wavetable into.
 * @param path - Path to file.
 * @return Result of load see WAVE_FILE_* for details.
 */
extern uint8_t wt_load(WaveTable* wave, char* name) {
  uint8_t header[HEADER_LEN];
  
  File f = SPIFFS.open(name, "r");
  if (!f) return WAVE_FILE_NOT_FOUND;

  // Read file header
  f.readBytes((char*)header, HEADER_LEN);

  // Check for magic identifier
  if (strncmp((char*)header, "wave", 4) != 0) {
    f.close();
    return WAVE_FILE_INVALID_HEADER;
  }

  // Check version
  if (header[VERSION_OFFSET] != 1) {
    f.close();
    return WAVE_FILE_UNKNOWN_VERSION;
  }

  // Read in wave
  strncpy(wave->name, name, WAVE_NAME_LEN);
  f.readBytes((char*)wave->data, WAVE_TABLE_LEN);
  f.close();

  // Check checksum
  if (calculateChecksum(wave) != header[CHECKSUM_OFFSET]) return WAVE_FILE_CHECKSUM_FAILED;

  return WAVE_FILE_OK;
}

/**
 * Save a wave table to ESP8266 filesystem.
 * 
 * @param wave - Pointer to a wavetable to save.
 * @param path - Path to file.
 * @return Result of load see WAVE_FILE_* for details.
 */
extern uint8_t wt_save(WaveTable* wave, char* name) {
  uint8_t header[HEADER_LEN] = "wave";
  header[VERSION_OFFSET] = 1;
  header[CHECKSUM_OFFSET] = calculateChecksum(wave);
  header[LENGTH_OFFSET] = (uint16_t)WAVE_TABLE_LEN;
  
  File f = SPIFFS.open(name, "w");
  if (!f) return WAVE_FILE_NOT_FOUND;

  // Write file header
  if (f.write(header, HEADER_LEN) == 0) {
    f.close();
    return WAVE_FILE_ERROR_WRITING_HEADER;
  }

  // Write data
  if (f.write(wave->data, WAVE_TABLE_LEN) == 0) {
    f.close();
    return WAVE_FILE_ERROR_WRITING_DATA;
  }
  
  f.close();
  return WAVE_FILE_OK;
}


/**
 * Zero wave definition
 */
const uint8_t zeroWave[] PROGMEM = {
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
};

/**
 * Set wave table to zero.
 */
extern void wt_zero(WaveTable* wave) {
  memcpy_P(wave->data, zeroWave, WAVE_TABLE_LEN);
}

/**
 * Invert the waveform
 */
extern void wt_invert(WaveTable* wave) {
  for (size_t i = 0; i < WAVE_TABLE_LEN; i++) {
    wave->data[i] = WAVE_DYNAMIC_RANGE - wave->data[i];
  }
}

/**
 * Mirror the waveform
 */
extern void wt_mirror(WaveTable* wave) {
  uint8_t temp[WAVE_TABLE_LEN];
  memcpy(temp, wave->data, WAVE_TABLE_LEN);
  for (size_t i = 0; i < WAVE_TABLE_LEN; i++) {
    wave->data[i] = temp[WAVE_TABLE_MAX - i];
  }
}

